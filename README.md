Система сборки в проекте cmake, все стандартно, в build директории cmake .. . Из зависимостей только boost. Компонент unit tests и хедеры для lockfree queue. 

В stress тестах как очередь используется только std::list, тк при работе с boost::lockfree::queue thread санитайзер показал наличие гонок в lockfree::queue. Вполне вероятно, проблема с тем, что я разрабатывал под arm, а в арме проблемы с memory_order_relaxed, но в репозитории нашел схожий [тикет](https://github.com/boostorg/lockfree/issues/22). На x86 не тестировал.

Предолжил достаточное гибкое решение по добавлению новых типов очередей(например очередь с приоритетами), так же предоставил классы, которые по разному работают с переполнением. При необходимости просто добавить новую стратегию и она должна работать со всеми очередями. Также без проблем можно расширить функционал логером, сборщиком статистики или системой мониторинга.

С точки зрения самого менеджера очередей решение не гибкое. Хотел сделать решение, позволяющее легко расширять операции Enqueue/Dequeue, но это выходило за рамки укзанных таймингов.

Предолжил более производительное решение с точки зрения обработки очередей. Но тут тоже большой простор для улучшения. Сейчас потоки много времени могут находится в состоянии busy wait, а также конкурировать за ресурсы. Была идея сделать разделение консьюмеров по потокам, но с учетом непонимания количества очередей, непонятно, как часто будет происходить рехеширование unordered_map, каждый раз при такой операции надо было заново делить итераторы между потоками. Так же была идея класть в очередь обновившиеся очереди, но тут узким местом был бы доступ к этой очереди. С учетом ограничения на использования только буста, не стал внедрять thread pool из boost asio, тк решение из коробки напрямую не подходило, а писать враппер, который расширял бы фунциональность, заняло бы значительное количество времени.

Решение так же можно было бы улучшить с точки зрения использования специализаций для reference, но тут слишком мало информации о возможных данных, поэтому остановился на передачи Value.

Так же хотел бы отметить, что при использовании boost::lockfree::queue есть ограничение на тип значения, он должен быть is_trivially_destructible. Пользователь получит сообщение при компиляции.

Спасибо! Жду фидбека! 